For my `web-content`, I have transferred both the haproxy.html file and the style.css file, but I did ask ChatGPT for help creating a new index.html file that simply says "It Works".
After that I went to work on my `Dockerfile` which is just a simple two line file that tells docker hub the image will run on httpd version 2.4, and copies the files from `web-content` into the instances `/htdocs` folder.<br><br>
[Link to web-content](web-content)<br>
[Link to Dockerfile](Dockerfile)<br><br>
There are many ways to build an image on Docker Hub, one you can do given the materials above is by using a Command Line Interface (CLI). In a CLI, the user must login to docker using `docker login`, then the user can build an image based on the given Dockerfile with a command like `docker build -t jackewing/cicd-project:latest .`. The `:latest` is called a "tag", which is used to identify a specific version of an image. it's more or less used as a name for the image version. To properly test and therfore use the image, the user must use the command `docker run -d -p 8080:8080 jackewing/cicd-project:latest`. Do remember through all of this that these are not the specific commands used for these actions, they are just examples. The `-d` is to run the instance in detatched mode, and the `-p` is to assign port connections between the host and the network.<br><br>
Creating a Personal Access Token (PAT) is simple in Docker Hub. first the user needs to go to their `Account Seettings` page and click the `Personal Access Tokens` tab on the left. After that the user needs to click `Generate New Token`, this will prompt the user for a name, an expiration date, and the tokens permissions. Finally the user is shown the token and must promptly store it somewhere as the token will never be shown again after closing the page. To create a repo secret, the user must first click the `Settings` tab, next they scroll down to the `Secrets and Variables` then click `Actions`. Next they need to click `New Repository Secret`. The user is then prompted to enter a name for the secret and the text the secret will refer to. For this project I have created two secrets called `DOCKER_TOKEN` and `DOCKER_USERNAME` containing the PAT and my Docker Hub Username respectively.<br><br>
A workflow can be triggered through many means, such as<br>
`Push Events`: Whenever a push is made.<br>
`Tag Events`: Whenever a tag is created.<br>
`Pull Request Events`: Whenever a pull request is opened, updated, reopened, or synchronized.<br>
`Scheduled Events (called Cron)`: Automatically at a given time.<br>
`Workflow and Repository Dispatch (also called Manual and External Trigger respectively)`: Triggered through Github UI or API for Workflow, and only externally though the Github API for Repository.<br> 
`Workflow Run (also called a Chain Triggers)`: Whenever another workflow is triggered.<br>
`and Webhook-Like Events`: Triggered after Github activities (Issue, Issue comment, Release, Fork, Watch/Star, Create, etc.).<br>
For this workflow I used the `Push Events` Trigger.<>br
The steps followed through the workflow are followed in descending order, these steps are as follows for my workflow file. <br>`Step 1: Checkout code`: This will download (checkout) all repo contents into the workflow so that Docker can build an image from them, the `@v4` refers to the version being used. <br>`Step 2: Set up Docker Buildx`: This will setup `Buildx`, a helpful upgrade to the previously used `docker build`. <br> `Step 3: Log in to Docker Hub`: This will (when followed by a proper username and password/PAT) log into Docker Hub so the workflow can properlly build and push the docker image. <br>`Step 4: Build and Push Docker image`: This will build the image on github and then push the image to the users Docker Hub.<br>What needs to be changed when using this workflow script in another repo is the 4th step, maybe the build, and maybe the 3rd step. The build is not static, some people may use EC2 instances, or other linux CLI's, or maybe even a different version of Ubuntu. The 3rd step references secrets named by me in Github, the user needs to either have the same named secrets with the same info or hard code it to their specific info. The 4th step once again uses my secret, but also hard coded is the name of my image. This needs to change to whatever the `username/image:tag` is that the user is trying to push to.<br><br>
[Link to workflow (Push Request)](.github/workflows/docker-build.yml_Push_Request)<br><br>
The way to test that the workflow worked is by going to Docker Hub and looking in your repositories for the repo tagged and named the same as whatever you pushed it as. And to verify the image works, you can run the `docker run` command on a CLI to see if a container can be made from the image.<br><br>
Tags are visibile by using the `git tag` command. Using this command the user can see all tags, with the `git show-ref --tags` command they can see each tag with more detail. And they can use `git show v*.*.*` to see a specific commit and what it references. Tagging a git repository has a lot of parts though. `git tag` `-a` `v*.*.*` `###XXX` `-m "tag message"` is an example of a full git tag, I'll explain each part.<br>
`git tag` and `v*.*.*`: These two sections are the initial tag command, a simple pointer to a commit for the repo.<br>
`-a` and `-m "tag message"`: These two work in tandem as well, they are used to add things like a tag author, a message, and a date.<br>
`###XXX`: This is an example of a commit hash, another identifier used in commits.<br>
Pushing tags is done with a simple `git push origin v*.*.*` for pushing a single tag, and `git push origin --tags` to push all tags to the repo.<br><br>
For this workflow I used the `Tag Events Trigger` and followed these steps.<br>
`Step 1: Checkout code`: Same as in the previous workflow.<br>
`Step 2: Set up Docker Buildx`: Same as in the previous workflow.<br>
`Step 3: Extract Docker metadata`: This is a step added to this workflow. This step will automatically create a Docker image tag and label based on the given repo state. It can create the next version number, the commit hash, the convention, and also the Git reference.<br>
`Step 4: Log in to Docker Hub`: Same as in the previous workflow.<br>
`Step 5: Build and Push Docker image`: This step has changed a bit. Instead of the image being tagged the same everytime, the step will refer to the new step for the name and tag of the image.<br>
What needs to be changed in this workflow file is the build (for the same reason as last time), step 3 (for the same reason as step 4 for the last workflow), and step 5. Step 5 adds a new way of nameing and tagging the image before it is pushed. Instead of nameing it the same everytime, it will look to step 3 for the newest version name that has been created.<br><br    >
[Link to workflow (Tag Request)](.github/workflows/docker-build.yml_Tag_Request)<br><br>
